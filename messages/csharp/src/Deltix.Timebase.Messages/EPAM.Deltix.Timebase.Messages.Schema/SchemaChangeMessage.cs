//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using EPAM.Deltix.Timebase.Messages;
using System;
using System.Collections.Generic;


namespace EPAM.Deltix.Timebase.Messages.Schema
{
    
    
    /// <summary>
    /// Message tha defines a change in stream schema.
    /// </summary>
    [SchemaElement(Name="com.epam.deltix.timebase.messages.schema.SchemaChangeMessage", Title="SchemaChangeMessage", Description=null)]
    public class SchemaChangeMessage : InstrumentMessage, ISchemaChangeMessageInterface
    {
        
        public new static string ClassName = "com.epam.deltix.timebase.messages.schema.SchemaChangeMessage";
        
        private IList<IClassDescriptorInterface> _previousState = null;
        
        private IList<IClassDescriptorInterface> _newState = null;
        
        private IList<ISchemaDescriptorChangeActionInterface> _descriptorChangeActions = null;
        
        private UInt64 _version = UInt64.MinValue;
        
        /// <summary>
        /// Creates an instance of SchemaChangeMessage object.
        /// </summary>
        public SchemaChangeMessage()
        {
        }
        
        #region Properties
        /// <summary>
        /// Previous schema state.
        /// </summary>
        [SchemaIgnore()]
        IReadOnlyList<IClassDescriptorInfo> ISchemaChangeMessageInfo.PreviousState
        {
            get
            {
                return ((IReadOnlyList<IClassDescriptorInterface>)(this._previousState));
            }
        }
        
        /// <summary>
        /// Previous schema state.
        /// </summary>
        [SchemaElement(Name=null, Title=null, Description=null)]
        [SchemaArrayType(IsNullable=true, IsElementNullable=false, ElementEncoding=null, ElementDataType=SchemaDataType.Default, ElementMinimum=null, ElementMaximum=null, ElementTypes=new Type[] {
                typeof(RecordClassDescriptor),
                typeof(EnumClassDescriptor)})]
        public virtual IList<IClassDescriptorInterface> PreviousState
        {
            get
            {
                return this._previousState;
            }
            set
            {
                if (((value == null) 
                            || (typeof(IReadOnlyList<IClassDescriptorInterface>).IsInstanceOfType(value) == true)))
                {
                    this._previousState = value;
                }
                else
                {
                    throw new System.InvalidOperationException("Assigned value must implement IReadOnlyList<IClassDescriptorInterface> interface." +
                            "");
                }
            }
        }
        
        /// <summary>
        /// New schema state.
        /// </summary>
        [SchemaIgnore()]
        IReadOnlyList<IClassDescriptorInfo> ISchemaChangeMessageInfo.NewState
        {
            get
            {
                return ((IReadOnlyList<IClassDescriptorInterface>)(this._newState));
            }
        }
        
        /// <summary>
        /// New schema state.
        /// </summary>
        [SchemaElement(Name=null, Title=null, Description=null)]
        [SchemaArrayType(IsNullable=false, IsElementNullable=false, ElementEncoding=null, ElementDataType=SchemaDataType.Default, ElementMinimum=null, ElementMaximum=null, ElementTypes=new Type[] {
                typeof(RecordClassDescriptor),
                typeof(EnumClassDescriptor)})]
        public virtual IList<IClassDescriptorInterface> NewState
        {
            get
            {
                return this._newState;
            }
            set
            {
                if (((value == null) 
                            || (typeof(IReadOnlyList<IClassDescriptorInterface>).IsInstanceOfType(value) == true)))
                {
                    this._newState = value;
                }
                else
                {
                    throw new System.InvalidOperationException("Assigned value must implement IReadOnlyList<IClassDescriptorInterface> interface." +
                            "");
                }
            }
        }
        
        /// <summary>
        /// New schema state.
        /// </summary>
        [SchemaIgnore()]
        IReadOnlyList<ISchemaDescriptorChangeActionInfo> ISchemaChangeMessageInfo.DescriptorChangeActions
        {
            get
            {
                return ((IReadOnlyList<ISchemaDescriptorChangeActionInterface>)(this._descriptorChangeActions));
            }
        }
        
        /// <summary>
        /// New schema state.
        /// </summary>
        [SchemaElement(Name=null, Title=null, Description=null)]
        [SchemaArrayType(IsNullable=false, IsElementNullable=false, ElementEncoding=null, ElementDataType=SchemaDataType.Default, ElementMinimum=null, ElementMaximum=null, ElementTypes=new Type[] {
                typeof(SchemaDescriptorChangeAction)})]
        public virtual IList<ISchemaDescriptorChangeActionInterface> DescriptorChangeActions
        {
            get
            {
                return this._descriptorChangeActions;
            }
            set
            {
                if (((value == null) 
                            || (typeof(IReadOnlyList<ISchemaDescriptorChangeActionInterface>).IsInstanceOfType(value) == true)))
                {
                    this._descriptorChangeActions = value;
                }
                else
                {
                    throw new System.InvalidOperationException("Assigned value must implement IReadOnlyList<ISchemaDescriptorChangeActionInterfac" +
                            "e> interface.");
                }
            }
        }
        
        /// <summary>
        /// Message version
        /// </summary>
        [SchemaElement(Name=null, Title=null, Description=null)]
        public virtual UInt64 Version
        {
            get
            {
                return this._version;
            }
            set
            {
                this._version = value;
            }
        }
        #endregion
        
        #region Property Helpers
        /// <summary>
        /// Flag that indicates whether property PreviousState has an assigned value.
        /// <returns>true if property has an assigned value, false otherwise.</returns>
        /// </summary>
        public bool HasPreviousState()
        {
            return (this._previousState != null);
        }
        
        /// <summary>
        /// Sets null to PreviousState property.
        /// </summary>
        public void NullifyPreviousState()
        {
            this._previousState = null;
        }
        
        /// <summary>
        /// Flag that indicates whether property NewState has an assigned value.
        /// <returns>true if property has an assigned value, false otherwise.</returns>
        /// </summary>
        public bool HasNewState()
        {
            return (this._newState != null);
        }
        
        /// <summary>
        /// Sets null to NewState property.
        /// </summary>
        public void NullifyNewState()
        {
            this._newState = null;
        }
        
        /// <summary>
        /// Flag that indicates whether property DescriptorChangeActions has an assigned value.
        /// <returns>true if property has an assigned value, false otherwise.</returns>
        /// </summary>
        public bool HasDescriptorChangeActions()
        {
            return (this._descriptorChangeActions != null);
        }
        
        /// <summary>
        /// Sets null to DescriptorChangeActions property.
        /// </summary>
        public void NullifyDescriptorChangeActions()
        {
            this._descriptorChangeActions = null;
        }
        
        /// <summary>
        /// Flag that indicates whether property Version has an assigned value.
        /// <returns>true if property has an assigned value, false otherwise.</returns>
        /// </summary>
        public bool HasVersion()
        {
            return (this._version != UInt64.MinValue);
        }
        
        /// <summary>
        /// Sets null to Version property.
        /// </summary>
        public void NullifyVersion()
        {
            this._version = UInt64.MinValue;
        }
        #endregion
        
        #region Message Methods
        /// <summary>
        /// Creates a new instance of message.
        /// <returns>New instance of message of the same type as this.</returns>
        /// </summary>
        protected override IRecordInterface CreateInstance()
        {
            return new SchemaChangeMessage();
        }
        
        /// <summary>
        /// Creates copy of this instance.
        /// <returns>Copy.</returns>
        /// </summary>
        ISchemaChangeMessageInfo ISchemaChangeMessageInfo.Clone()
        {
            return ((ISchemaChangeMessageInfo)(this.CloneImpl()));
        }
        
        /// <summary>
        /// Creates copy of this instance.
        /// <returns>Copy.</returns>
        /// </summary>
        ISchemaChangeMessageInterface ISchemaChangeMessageInterface.Clone()
        {
            return ((ISchemaChangeMessageInterface)(this.CloneImpl()));
        }
        
        /// <summary>
        /// Creates copy of this instance.
        /// <returns>Copy.</returns>
        /// </summary>
        public new SchemaChangeMessage Clone()
        {
            return ((SchemaChangeMessage)(this.CloneImpl()));
        }
        
        /// <summary>
        /// Deep copies content from src instance to this.
        /// <param name="source">Source for copy.</param>
        /// <returns>this.</returns>
        /// </summary>
        protected override IRecordInterface CopyFromImpl(IRecordInfo source)
        {
            base.CopyFromImpl(source);
            if (typeof(ISchemaChangeMessageInfo).IsInstanceOfType(source))
            {
                ISchemaChangeMessageInfo typedSource = ((ISchemaChangeMessageInfo)(source));
                if ((typedSource.PreviousState != null))
                {
                    this.PreviousState = new List<IClassDescriptorInterface>(typedSource.PreviousState.Count);
                    int i;
                    for (i = 0; (i < typedSource.PreviousState.Count); i = (i + 1))
                    {
                        IClassDescriptorInfo item = typedSource.PreviousState[i];
                        if ((item == null))
                        {
                            this.PreviousState.Add(null);
                        }
                        else
                        {
                            this.PreviousState.Add(((IClassDescriptorInterface)(item.Clone())));
                        }
                    }
                }
                else
                {
                    this.PreviousState = null;
                }
                if ((typedSource.NewState != null))
                {
                    this.NewState = new List<IClassDescriptorInterface>(typedSource.NewState.Count);
                    int i;
                    for (i = 0; (i < typedSource.NewState.Count); i = (i + 1))
                    {
                        IClassDescriptorInfo item = typedSource.NewState[i];
                        if ((item == null))
                        {
                            this.NewState.Add(null);
                        }
                        else
                        {
                            this.NewState.Add(((IClassDescriptorInterface)(item.Clone())));
                        }
                    }
                }
                else
                {
                    this.NewState = null;
                }
                if ((typedSource.DescriptorChangeActions != null))
                {
                    this.DescriptorChangeActions = new List<ISchemaDescriptorChangeActionInterface>(typedSource.DescriptorChangeActions.Count);
                    int i;
                    for (i = 0; (i < typedSource.DescriptorChangeActions.Count); i = (i + 1))
                    {
                        ISchemaDescriptorChangeActionInfo item = typedSource.DescriptorChangeActions[i];
                        if ((item == null))
                        {
                            this.DescriptorChangeActions.Add(null);
                        }
                        else
                        {
                            this.DescriptorChangeActions.Add(((ISchemaDescriptorChangeActionInterface)(item.Clone())));
                        }
                    }
                }
                else
                {
                    this.DescriptorChangeActions = null;
                }
                this.Version = typedSource.Version;
            }
            return this;
        }
        
        /// <summary>
        /// Deep copies content from src instance to this.
        /// <param name="source">Source for copy.</param>
        /// <returns>this.</returns>
        /// </summary>
        ISchemaChangeMessageInterface ISchemaChangeMessageInterface.CopyFrom(IRecordInfo source)
        {
            return ((ISchemaChangeMessageInterface)(this.CopyFromImpl(source)));
        }
        
        /// <summary>
        /// Deep copies content from src instance to this.
        /// <param name="source">Source for copy.</param>
        /// <returns>this.</returns>
        /// </summary>
        public new SchemaChangeMessage CopyFrom(IRecordInfo source)
        {
            return ((SchemaChangeMessage)(this.CopyFromImpl(source)));
        }
        
        /// <summary>
        /// Set null to all fields of this instance.
        /// <returns>this.</returns>
        /// </summary>
        protected override IRecordInterface NullifyImpl()
        {
            base.NullifyImpl();
            this.NullifyPreviousState();
            this.NullifyNewState();
            this.NullifyDescriptorChangeActions();
            this.NullifyVersion();
            return this;
        }
        
        /// <summary>
        /// Set null to all fields of this instance.
        /// <returns>this.</returns>
        /// </summary>
        ISchemaChangeMessageInterface ISchemaChangeMessageInterface.Nullify()
        {
            return ((ISchemaChangeMessageInterface)(this.NullifyImpl()));
        }
        
        /// <summary>
        /// Set null to all fields of this instance.
        /// <returns>this.</returns>
        /// </summary>
        public new SchemaChangeMessage Nullify()
        {
            return ((SchemaChangeMessage)(this.NullifyImpl()));
        }
        
        /// <summary>
        /// Reset all instance field to their default states.
        /// <returns>this.</returns>
        /// </summary>
        protected override IRecordInterface ResetImpl()
        {
            base.ResetImpl();
            this._previousState = null;
            this._newState = null;
            this._descriptorChangeActions = null;
            this._version = UInt64.MinValue;
            return this;
        }
        
        /// <summary>
        /// Reset all instance field to their default states.
        /// <returns>this.</returns>
        /// </summary>
        ISchemaChangeMessageInterface ISchemaChangeMessageInterface.Reset()
        {
            return ((ISchemaChangeMessageInterface)(this.ResetImpl()));
        }
        
        /// <summary>
        /// Reset all instance field to their default states.
        /// <returns>this.</returns>
        /// </summary>
        public new SchemaChangeMessage Reset()
        {
            return ((SchemaChangeMessage)(this.ResetImpl()));
        }
        #endregion
        
        #region Standard Methods
        /// <summary>
        /// Determines whether the specified object is equal to the current object.
        /// <param name="obj">The object to compare with the current object.</param>
        /// <returns>true if the specified object is equal to the current object; otherwise, false.</returns>
        /// </summary>
        public virtual bool Equals(SchemaChangeMessage obj)
        {
            if ((obj == null))
            {
                return false;
            }
            if (((this.PreviousState != null) 
                        && (obj.PreviousState != null)))
            {
                if ((this.PreviousState.Count != obj.PreviousState.Count))
                {
                    return false;
                }
                int i;
                for (i = 0; (i < obj.PreviousState.Count); i = (i + 1))
                {
                    if (((this.PreviousState[i] != null) 
                                && (obj.PreviousState[i] != null)))
                    {
                        if ((this.PreviousState[i].Equals(obj.PreviousState[i]) != true))
                        {
                            return false;
                        }
                    }
                    else
                    {
                        if ((this.PreviousState[i] != obj.PreviousState[i]))
                        {
                            return false;
                        }
                    }
                }
            }
            else
            {
                if ((this.PreviousState != obj.PreviousState))
                {
                    return false;
                }
            }
            if (((this.NewState != null) 
                        && (obj.NewState != null)))
            {
                if ((this.NewState.Count != obj.NewState.Count))
                {
                    return false;
                }
                int i;
                for (i = 0; (i < obj.NewState.Count); i = (i + 1))
                {
                    if (((this.NewState[i] != null) 
                                && (obj.NewState[i] != null)))
                    {
                        if ((this.NewState[i].Equals(obj.NewState[i]) != true))
                        {
                            return false;
                        }
                    }
                    else
                    {
                        if ((this.NewState[i] != obj.NewState[i]))
                        {
                            return false;
                        }
                    }
                }
            }
            else
            {
                if ((this.NewState != obj.NewState))
                {
                    return false;
                }
            }
            if (((this.DescriptorChangeActions != null) 
                        && (obj.DescriptorChangeActions != null)))
            {
                if ((this.DescriptorChangeActions.Count != obj.DescriptorChangeActions.Count))
                {
                    return false;
                }
                int i;
                for (i = 0; (i < obj.DescriptorChangeActions.Count); i = (i + 1))
                {
                    if (((this.DescriptorChangeActions[i] != null) 
                                && (obj.DescriptorChangeActions[i] != null)))
                    {
                        if ((this.DescriptorChangeActions[i].Equals(obj.DescriptorChangeActions[i]) != true))
                        {
                            return false;
                        }
                    }
                    else
                    {
                        if ((this.DescriptorChangeActions[i] != obj.DescriptorChangeActions[i]))
                        {
                            return false;
                        }
                    }
                }
            }
            else
            {
                if ((this.DescriptorChangeActions != obj.DescriptorChangeActions))
                {
                    return false;
                }
            }
            if ((this.Version != obj.Version))
            {
                return false;
            }
            return base.Equals(obj);
        }
        
        /// <summary>
        /// Determines whether the specified object is equal to the current object.
        /// <param name="obj">The object to compare with the current object.</param>
        /// <returns>true if the specified object is equal to the current object; otherwise, false.</returns>
        /// </summary>
        public override bool Equals(object obj)
        {
            if ((typeof(SchemaChangeMessage).IsInstanceOfType(obj) == false))
            {
                return false;
            }
            return this.Equals(((SchemaChangeMessage)(obj)));
        }
        
        /// <summary>
        /// Calculates a hash code for the current object.
        /// <returns>A hash code for the current object.</returns>
        /// </summary>
        public override int GetHashCode()
        {
            unchecked
            {
            int hash = ((int)(2166136261u));
            if ((this.PreviousState == null))
            {
                hash = ((hash * 16777619) 
                            + 0);
            }
            else
            {
                int i;
                for (i = 0; (i < this.PreviousState.Count); i = (i + 1))
                {
                    if ((this.PreviousState[i] == null))
                    {
                        hash = ((hash * 16777619) 
                                    + 0);
                    }
                    else
                    {
                        hash = ((hash * 16777619) 
                                    + this.PreviousState[i].GetHashCode());
                    }
                }
            }
            if ((this.NewState == null))
            {
                hash = ((hash * 16777619) 
                            + 0);
            }
            else
            {
                int i;
                for (i = 0; (i < this.NewState.Count); i = (i + 1))
                {
                    if ((this.NewState[i] == null))
                    {
                        hash = ((hash * 16777619) 
                                    + 0);
                    }
                    else
                    {
                        hash = ((hash * 16777619) 
                                    + this.NewState[i].GetHashCode());
                    }
                }
            }
            if ((this.DescriptorChangeActions == null))
            {
                hash = ((hash * 16777619) 
                            + 0);
            }
            else
            {
                int i;
                for (i = 0; (i < this.DescriptorChangeActions.Count); i = (i + 1))
                {
                    if ((this.DescriptorChangeActions[i] == null))
                    {
                        hash = ((hash * 16777619) 
                                    + 0);
                    }
                    else
                    {
                        hash = ((hash * 16777619) 
                                    + this.DescriptorChangeActions[i].GetHashCode());
                    }
                }
            }
            hash = ((hash * 16777619) 
                        + this.Version.GetHashCode());
            return ((hash * 16777619) 
                        + base.GetHashCode());
            }
        }
        
        /// <summary>
        /// Appends an object state to a given StringBuilder in a form of JSON.
        /// <returns>A StringBuilder that was used to append the object to.</returns>
        /// </summary>
        public override System.Text.StringBuilder ToString(System.Text.StringBuilder builder)
        {
            builder.Append("{ \"$type\":  \"SchemaChangeMessage\"");
            if (this.HasPreviousState())
            {
                builder.Append(", \"PreviousState\": [");
                int i;
                for (i = 0; (i < this.PreviousState.Count); i = (i + 1))
                {
                    if ((i != 0))
                    {
                        builder.Append(",");
                    }
                    this.PreviousState[i].ToString(builder);
                }
                builder.Append("]");
            }
            if (this.HasNewState())
            {
                builder.Append(", \"NewState\": [");
                int i;
                for (i = 0; (i < this.NewState.Count); i = (i + 1))
                {
                    if ((i != 0))
                    {
                        builder.Append(",");
                    }
                    this.NewState[i].ToString(builder);
                }
                builder.Append("]");
            }
            if (this.HasDescriptorChangeActions())
            {
                builder.Append(", \"DescriptorChangeActions\": [");
                int i;
                for (i = 0; (i < this.DescriptorChangeActions.Count); i = (i + 1))
                {
                    if ((i != 0))
                    {
                        builder.Append(",");
                    }
                    this.DescriptorChangeActions[i].ToString(builder);
                }
                builder.Append("]");
            }
            if (this.HasVersion())
            {
                builder.Append(", \"Version\": ");
                builder.Append(this.Version);
            }
            if (this.HasTimeStampMs())
            {
                builder.Append(", \"TimeStampMs\": \"");
                builder.Append(this.TimeStampMs);
                builder.Append("\"");
            }
            if (this.HasNanoTime())
            {
                builder.Append(", \"NanoTime\": \"");
                builder.Append(this.NanoTime);
                builder.Append("\"");
            }
            if (this.HasSymbol())
            {
                builder.Append(", \"Symbol\": \"");
                builder.Append(this.Symbol);
                builder.Append("\"");
            }
            builder.Append("}");
            return builder;
        }
        
        /// <summary>
        /// Returns a string that represents the current object.
        /// <returns>A string that represents the current object.</returns>
        /// </summary>
        public override string ToString()
        {
            return this.ToString(new System.Text.StringBuilder()).ToString();
        }
        #endregion
    }
}
